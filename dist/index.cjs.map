{"version":3,"sources":["../src/index.ts","../src/lib/readers.ts","../src/lib/utils.ts","../src/lib/statusandheaders.ts","../src/lib/warcrecord.ts","../src/lib/warcparser.ts","../src/lib/warcserializer.ts","../src/lib/indexer.ts"],"sourcesContent":["export {\n  BaseAsyncIterReader,\n  AsyncIterReader,\n  LimitReader,\n  NoConcatInflator,\n  StatusAndHeadersParser,\n  StatusAndHeaders,\n  WARCParser,\n  WARCSerializer,\n  WARCRecord,\n  WARC_1_0,\n  WARC_1_1,\n  Indexer,\n  CDXIndexer,\n  postToGetUrl,\n  getSurt,\n  appendRequestQuery,\n  jsonToQueryParams,\n  jsonToQueryString,\n  mfdToQueryParams,\n  mfdToQueryString,\n  concatChunks,\n  splitChunk,\n} from \"./lib\";\n\nexport type {\n  WARCParserOpts,\n  WARCSerializerOpts,\n  WARCRecordOpts,\n  WARCType,\n} from \"./lib\";\n\nexport type {\n  AsyncIterReaderOpts,\n  Source,\n  SourceReader,\n  SourceReadable,\n  StreamResult,\n  StreamResults,\n  Request,\n} from \"./lib\";\n","import pako from \"pako\";\nimport { Source, SourceReader } from \"./types\";\nimport { splitChunk, concatChunks } from \"./utils\";\n\nconst decoder = new TextDecoder(\"utf-8\");\n\n// ===========================================================================\nexport class NoConcatInflator<T extends BaseAsyncIterReader> extends pako.Inflate {\n  reader: T;\n  ended = false;\n  chunks: Uint8Array[] = [];\n\n  constructor(options: pako.InflateOptions, reader: T) {\n    super(options);\n    this.reader = reader;\n  }\n\n  override onEnd(status: pako.ReturnCodes) {\n    this.err = status;\n    if (!this.err) {\n      // @ts-expect-error strm is not implemented in typescript types\n      this.reader._rawOffset += this.strm.total_in;\n    }\n  }\n}\n\n// ===========================================================================\nexport abstract class BaseAsyncIterReader {\n  static async readFully(iter: AsyncIterable<Uint8Array>) : Promise<Uint8Array> {\n    const chunks = [];\n    let size = 0;\n\n    for await (const chunk of iter) {\n      chunks.push(chunk);\n      size += chunk.byteLength;\n    }\n\n    return concatChunks(chunks, size);\n  }\n\n  abstract [Symbol.asyncIterator](): AsyncIterator<Uint8Array>;\n\n  getReadableStream() {\n    const streamIter = this[Symbol.asyncIterator]();\n\n    return new ReadableStream({\n      pull(controller) {\n        return streamIter.next().then((result) => {\n          // all done;\n          if (result.done || !result.value) {\n            controller.close();\n          } else {\n            controller.enqueue(result.value);\n          }\n        });\n      },\n    });\n  }\n\n  async readFully(): Promise<Uint8Array> {\n    return await BaseAsyncIterReader.readFully(this);\n  }\n\n  abstract readlineRaw(maxLength?: number): Promise<Uint8Array | null>;\n\n  async readline(maxLength = 0) {\n    const lineBuff = await this.readlineRaw(maxLength);\n    return lineBuff ? decoder.decode(lineBuff) : \"\";\n  }\n\n  async *iterLines(maxLength = 0) {\n    let line = null;\n\n    while ((line = await this.readline(maxLength))) {\n      yield line;\n    }\n  }\n}\n\n\n// ===========================================================================\nexport type AsyncIterReaderOpts = {\n  raw: boolean;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any -- type guard\nfunction isIterable(input: any): input is Iterable<Uint8Array> {\n  return input && Symbol.iterator in Object(input);\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any -- type guard\nfunction isAsyncIterable(input: any): input is AsyncIterable<Uint8Array> {\n  return input && Symbol.asyncIterator in Object(input);\n}\n\n// ===========================================================================\nexport class AsyncIterReader extends BaseAsyncIterReader {\n  compressed!: string | null;\n  opts!: AsyncIterReaderOpts;\n  inflator!: NoConcatInflator<this> | null;\n\n  _sourceIter: AsyncIterator<Uint8Array | null>;\n\n  lastValue: Uint8Array | null;\n  errored: boolean;\n  _savedChunk: Uint8Array | null;\n  _rawOffset: number;\n  _readOffset: number;\n  numChunks: number;\n\n  constructor(\n    streamOrIter: Source,\n    compressed: string | null = \"gzip\",\n    dechunk = false\n  ) {\n    super();\n    this.compressed = compressed;\n    this.opts = { raw: compressed === \"deflateRaw\" };\n\n    this.inflator = compressed ? new NoConcatInflator(this.opts, this) : null;\n\n    let source: AsyncIterable<Uint8Array>;\n    if (isAsyncIterable(streamOrIter)) {\n      source = streamOrIter;\n    } else if (\n      typeof streamOrIter === \"object\" &&\n      \"read\" in streamOrIter &&\n      typeof streamOrIter.read === \"function\"\n    ) {\n      source = AsyncIterReader.fromReadable(streamOrIter);\n    } else if (streamOrIter instanceof ReadableStream) {\n      source = AsyncIterReader.fromReadable(streamOrIter.getReader());\n    } else if (isIterable(streamOrIter)) {\n      source = AsyncIterReader.fromIter(streamOrIter);\n    } else {\n      throw new TypeError(\"Invalid Stream Source\");\n    }\n\n    if (dechunk) {\n      this._sourceIter = this.dechunk(source);\n    } else {\n      this._sourceIter = source[Symbol.asyncIterator]();\n    }\n\n    this.lastValue = null;\n\n    this.errored = false;\n\n    this._savedChunk = null;\n\n    this._rawOffset = 0;\n    this._readOffset = 0;\n\n    this.numChunks = 0;\n  }\n\n  async _loadNext() {\n    const res = await this._sourceIter.next();\n    return !res.done ? res.value : null;\n  }\n\n  async *dechunk(\n    source: AsyncIterable<Uint8Array>\n  ): AsyncIterator<Uint8Array | null> {\n    const reader =\n      source instanceof AsyncIterReader\n        ? source\n        : new AsyncIterReader(source, null);\n\n    let size = -1;\n    let first = true;\n\n    while (size != 0) {\n      const lineBuff = await reader.readlineRaw(64);\n      let chunk: Uint8Array = new Uint8Array();\n\n      size = lineBuff ? parseInt(decoder.decode(lineBuff), 16) : 0;\n\n      if (!size || size > 2 ** 32) {\n        if (Number.isNaN(size) || size > 2 ** 32) {\n          if (!first) {\n            this.errored = true;\n          }\n          yield lineBuff;\n          break;\n        }\n      } else {\n        chunk = await reader.readSize(size);\n        if (chunk.length != size) {\n          if (!first) {\n            this.errored = true;\n          } else {\n            yield lineBuff;\n          }\n          yield chunk;\n          break;\n        }\n      }\n\n      const sep = await reader.readSize(2);\n\n      if (sep[0] != 13 || sep[1] != 10) {\n        if (!first) {\n          this.errored = true;\n        } else {\n          yield lineBuff;\n        }\n        yield chunk;\n        yield sep;\n        break;\n      } else {\n        first = false;\n        if (!chunk || size === 0) {\n          return;\n        } else {\n          yield chunk;\n        }\n      }\n    }\n\n    yield* reader;\n  }\n\n  unread(chunk: Uint8Array) {\n    if (!chunk.length) {\n      return;\n    }\n\n    this._readOffset -= chunk.length;\n\n    /* istanbul ignore if */\n    if (this._savedChunk) {\n      console.log(\"Already have chunk!\");\n    }\n\n    this._savedChunk = chunk;\n  }\n\n  async _next() {\n    if (this._savedChunk) {\n      const chunk = this._savedChunk;\n      this._savedChunk = null;\n      return chunk;\n    }\n\n    if (this.compressed) {\n      const newValue = this._getNextChunk();\n      if (newValue) {\n        return newValue;\n      }\n    }\n\n    let value = await this._loadNext();\n\n    while (this.compressed && value) {\n      this._push(value);\n\n      const newValue = this._getNextChunk(value);\n      if (newValue) {\n        return newValue;\n      }\n      value = await this._loadNext();\n    }\n\n    return value;\n  }\n\n  _push(value: Uint8Array) {\n    // only called if this.compressed is not null\n    if (!this.inflator) {\n      throw new Error(\n        \"AsyncIterReader cannot call _push when this.compressed is null\"\n      );\n    }\n    this.lastValue = value;\n\n    if (this.inflator.ended) {\n      this.inflator = new NoConcatInflator(this.opts, this);\n    }\n    this.inflator.push(value);\n\n    // \"deflate\" allows automatically trying \"deflateRaw\", while \"gzip\" does not\n    if (\n      this.inflator.err &&\n      this.inflator.ended &&\n      this.compressed === \"deflate\" &&\n      this.opts.raw === false &&\n      this.numChunks === 0\n    ) {\n      this.opts.raw = true;\n      this.compressed = \"deflateRaw\";\n\n      this.inflator = new NoConcatInflator(this.opts, this);\n      this.inflator.push(value);\n    }\n  }\n\n  _getNextChunk(original?: Uint8Array) {\n    // only called if this.compressed is not null\n    if (!this.inflator) {\n      throw new Error(\n        \"AsyncIterReader cannot call _getNextChunk when this.compressed is null\"\n      );\n    }\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      if (this.inflator.chunks.length > 0) {\n        this.numChunks++;\n        return this.inflator.chunks.shift();\n      }\n\n      if (this.inflator.ended) {\n        if (this.inflator.err !== 0) {\n          // assume not compressed\n          this.compressed = null;\n          return original;\n        }\n\n        // @ts-expect-error strm is not implemented in typescript types\n        const avail_in = this.inflator.strm.avail_in;\n\n        if (avail_in && this.lastValue) {\n          this._push(this.lastValue.slice(-avail_in));\n          continue;\n        }\n      }\n\n      return null;\n    }\n  }\n\n  async *[Symbol.asyncIterator]() {\n    let chunk = null;\n    while ((chunk = await this._next())) {\n      this._readOffset += chunk.length;\n      yield chunk;\n    }\n  }\n\n  async readlineRaw(maxLength?: number) {\n    const chunks = [];\n    let size = 0;\n\n    let inx = -1;\n\n    let lastChunk = null;\n\n    for await (const chunk of this) {\n      if (maxLength && size + chunk.byteLength > maxLength) {\n        lastChunk = chunk;\n        inx = maxLength - size - 1;\n        const lineInx = chunk.slice(0, inx + 1).indexOf(10);\n        if (lineInx >= 0) {\n          inx = lineInx;\n        }\n        break;\n      }\n\n      inx = chunk.indexOf(10);\n\n      if (inx >= 0) {\n        lastChunk = chunk;\n        break;\n      }\n\n      chunks.push(chunk);\n      size += chunk.byteLength;\n    }\n\n    if (lastChunk) {\n      const [first, remainder] = splitChunk(lastChunk, inx + 1);\n      chunks.push(first);\n      size += first.byteLength;\n\n      this.unread(remainder);\n    } else if (!chunks.length) {\n      return null;\n    }\n\n    return concatChunks(chunks, size);\n  }\n\n  override async readFully() : Promise<Uint8Array> {\n    return (await this._readOrSkip())[1];\n  }\n\n  async readSize(sizeLimit: number) : Promise<Uint8Array> {\n    return (await this._readOrSkip(sizeLimit))[1];\n  }\n\n  async skipSize(sizeLimit: number) : Promise<number> {\n    return (await this._readOrSkip(sizeLimit, true))[0];\n  }\n\n  async _readOrSkip(sizeLimit = -1, skip = false) {\n    const chunks: Uint8Array[] = [];\n    let size = 0;\n\n    //while ((res = await this._readiter.next()) && (chunk = res.value)) {\n    for await (const chunk of this) {\n      if (sizeLimit >= 0) {\n        if (chunk.length > sizeLimit) {\n          const [first, remainder] = splitChunk(chunk, sizeLimit);\n          if (!skip) {\n            chunks.push(first);\n          }\n          size += first.byteLength;\n          this.unread(remainder);\n          break;\n        } else if (chunk.length === sizeLimit) {\n          if (!skip) {\n            chunks.push(chunk);\n          }\n          size += chunk.byteLength;\n          sizeLimit = 0;\n          break;\n        } else {\n          sizeLimit -= chunk.length;\n        }\n      }\n      if (!skip) {\n        chunks.push(chunk);\n      }\n      size += chunk.byteLength;\n    }\n\n    if (skip) {\n      return [size, new Uint8Array()] as const;\n    }\n    return [size, concatChunks(chunks, size)] as const;\n  }\n\n  getReadOffset() {\n    return this._readOffset;\n  }\n\n  getRawOffset() {\n    return this.compressed ? this._rawOffset : this._readOffset;\n  }\n\n  getRawLength(prevOffset: number): number {\n    if (this.compressed) {\n      // @ts-expect-error strm is not implemented in typescript types\n      return this.inflator.strm.total_in;\n    }\n    return this._readOffset - prevOffset;\n  }\n\n  static fromReadable<Readable extends SourceReader>(source: Readable) {\n    const iterable = {\n      async *[Symbol.asyncIterator]() {\n        let res = null;\n\n        while ((res = await source.read()) && !res.done) {\n          yield res.value as Uint8Array;\n        }\n      },\n    };\n\n    return iterable;\n  }\n\n  static fromIter(source: Iterable<Uint8Array>) {\n    const iterable = {\n      async *[Symbol.asyncIterator]() {\n        for (const chunk of source) {\n          yield chunk;\n        }\n      },\n    };\n\n    return iterable;\n  }\n}\n\n// ===========================================================================\nexport class LimitReader extends BaseAsyncIterReader {\n  sourceIter!: AsyncIterReader;\n  length!: number;\n  limit!: number;\n  skip!: number;\n\n  constructor(streamIter: AsyncIterReader, limit: number, skip = 0) {\n    super();\n    this.sourceIter = streamIter;\n    this.length = limit;\n    this.limit = limit;\n    this.skip = skip;\n  }\n\n  setLimitSkip(limit: number, skip = 0) {\n    this.limit = limit;\n    this.skip = skip;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    if (this.limit <= 0) {\n      return;\n    }\n\n    for await (let chunk of this.sourceIter) {\n      if (this.skip > 0) {\n        if (chunk.length >= this.skip) {\n          const [, /*first*/ remainder] = splitChunk(chunk, this.skip);\n          chunk = remainder;\n          this.skip = 0;\n        } else {\n          this.skip -= chunk.length;\n          continue;\n        }\n      }\n\n      if (chunk.length > this.limit) {\n        const [first, remainder] = splitChunk(chunk, this.limit);\n        chunk = first;\n\n        if (this.sourceIter.unread) {\n          this.sourceIter.unread(remainder);\n        }\n      }\n\n      if (chunk.length) {\n        this.limit -= chunk.length;\n\n        yield chunk;\n      }\n\n      if (this.limit <= 0) {\n        break;\n      }\n    }\n  }\n\n  async readlineRaw(maxLength?: number) {\n    if (this.limit <= 0) {\n      return null;\n    }\n\n    const result = await this.sourceIter.readlineRaw(\n      maxLength ? Math.min(maxLength, this.limit) : this.limit\n    );\n    this.limit -= result?.length || 0;\n    return result;\n  }\n\n  async skipFully() {\n    const origLimit = this.limit;\n\n    while (this.limit > 0) {\n      this.limit -= await this.sourceIter.skipSize(this.limit);\n    }\n\n    return origLimit;\n  }\n}\n\n","import { Request } from \"./types\";\n\nexport function binaryToString(data: Uint8Array | string) {\n  let string;\n\n  if (typeof data === \"string\") {\n    string = data;\n  } else if (data && data.length) {\n    string = data.reduce((accumulator, value) => {\n      accumulator += String.fromCharCode(value);\n      return accumulator;\n    }, \"\");\n  } else if (data) {\n    string = data.toString();\n  } else {\n    string = \"\";\n  }\n  return \"__wb_post_data=\" + Buffer.from(string, \"latin1\").toString(\"base64\");\n}\n\nexport function rxEscape(string: string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\n\nexport function getSurt(url: string) {\n  try {\n    if (!url.startsWith(\"https:\") && !url.startsWith(\"http:\")) {\n      return url;\n    }\n    url = url.replace(/^(https?:\\/\\/)www\\d*\\./, \"$1\");\n    const urlLower = url.toLowerCase();\n    const urlObj = new URL(urlLower);\n\n    const hostParts = urlObj.hostname.split(\".\").reverse();\n    let surt = hostParts.join(\",\");\n    if (urlObj.port) {\n      surt += \":\" + urlObj.port;\n    }\n    surt += \")\";\n    surt += urlObj.pathname;\n    if (urlObj.search) {\n      urlObj.searchParams.sort();\n      surt += urlObj.search;\n      for (const [key, value] of urlObj.searchParams.entries()) {\n        if (!value) {\n          const rx = new RegExp(`(?<=[&?])${rxEscape(key)}=(?=&|$)`);\n          if (!rx.exec(urlLower)) {\n            surt = surt.replace(rx, key);\n          }\n        }\n      }\n    }\n    return surt;\n  } catch (e) {\n    return url;\n  }\n}\n\nexport function postToGetUrl(request: Request) {\n  const { method, headers, postData } = request;\n\n  if (method === \"GET\") {\n    return false;\n  }\n\n  const requestMime = (headers.get(\"content-type\") || \"\").split(\";\")[0];\n\n  function decodeIfNeeded(postData: Uint8Array | string): string {\n    if (postData instanceof Uint8Array) {\n      postData = new TextDecoder().decode(postData);\n    }\n    return postData;\n  }\n\n  let query = \"\";\n\n  switch (requestMime) {\n    case \"application/x-www-form-urlencoded\":\n      query = decodeIfNeeded(postData);\n      break;\n\n    case \"application/json\":\n      query = jsonToQueryString(decodeIfNeeded(postData));\n      break;\n\n    case \"text/plain\":\n      try {\n        query = jsonToQueryString(decodeIfNeeded(postData), false);\n      } catch (e) {\n        query = binaryToString(postData);\n      }\n      break;\n\n    case \"multipart/form-data\": {\n      const content_type = headers.get(\"content-type\");\n      if (!content_type) {\n        throw new Error(\n          \"utils cannot call postToGetURL when missing content-type header\"\n        );\n      }\n      query = mfdToQueryString(decodeIfNeeded(postData), content_type);\n      break;\n    }\n\n    default:\n      query = binaryToString(postData);\n  }\n\n  if (query !== null) {\n    request.url = appendRequestQuery(request.url, query, request.method);\n    request.method = \"GET\";\n    request.requestBody = query;\n    return true;\n  }\n\n  return false;\n}\n\nexport function appendRequestQuery(url: string, query: string, method: string) {\n  if (!method) {\n    return url;\n  }\n\n  const start = url.indexOf(\"?\") > 0 ? \"&\" : \"?\";\n\n  return `${url}${start}__wb_method=${method}&${query}`;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function jsonToQueryParams(json: string | any, ignoreInvalid = true) {\n  if (typeof json === \"string\") {\n    try {\n      json = JSON.parse(json);\n    } catch (e) {\n      json = {};\n    }\n  }\n\n  const q = new URLSearchParams();\n\n  const dupes: Record<string, number> = {};\n\n  const getKey = (key: string) => {\n    if (!q.has(key)) {\n      return key;\n    }\n\n    if (!(key in dupes)) {\n      dupes[key] = 1;\n    }\n    return key + \".\" + ++dupes[key] + \"_\";\n  };\n\n  try {\n    JSON.stringify(json, (k, v) => {\n      if (![\"object\", \"function\"].includes(typeof v)) {\n        q.set(getKey(k), v);\n      }\n      return v;\n    });\n  } catch (e) {\n    if (!ignoreInvalid) {\n      throw e;\n    }\n  }\n  return q;\n}\n\nexport function mfdToQueryParams(\n  mfd: string | Uint8Array,\n  contentType: string\n) {\n  const params = new URLSearchParams();\n\n  if (mfd instanceof Uint8Array) {\n    mfd = new TextDecoder().decode(mfd);\n  }\n\n  try {\n    const boundary = contentType.split(\"boundary=\")[1];\n\n    const parts = mfd.split(new RegExp(\"-*\" + boundary + \"-*\", \"mi\"));\n\n    for (const part of parts) {\n      const m = part.trim().match(/name=\"([^\"]+)\"\\r\\n\\r\\n(.*)/im);\n      if (m) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- match checked\n        params.set(m[1]!, m[2]!);\n      }\n    }\n  } catch (e) {\n    // ignore invalid, don't add params\n  }\n\n  return params;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function jsonToQueryString(json: any, ignoreInvalid = true) {\n  return jsonToQueryParams(json, ignoreInvalid).toString();\n}\n\nexport function mfdToQueryString(\n  mfd: string | Uint8Array,\n  contentType: string\n) {\n  return mfdToQueryParams(mfd, contentType).toString();\n}\n\n// ===========================================================================\n// parsing utils\n\nexport function concatChunks(chunks: Uint8Array[], size: number): Uint8Array {\n  if (chunks.length === 1) {\n    return chunks[0] as Uint8Array;\n  }\n  const buffer = new Uint8Array(size);\n\n  let offset = 0;\n\n  for (const chunk of chunks) {\n    buffer.set(chunk, offset);\n    offset += chunk.byteLength;\n  }\n\n  return buffer;\n}\n\nexport function splitChunk(\n  chunk: Uint8Array,\n  inx: number\n): [Uint8Array, Uint8Array] {\n  return [chunk.slice(0, inx), chunk.slice(inx)];\n}\n","import { concatChunks, splitChunk } from \"./utils\";\nimport { AsyncIterReader } from \"./readers\";\n\nexport const CRLF = new Uint8Array([13, 10]);\nexport const CRLFCRLF = new Uint8Array([13, 10, 13, 10]);\n\nconst decoder = new TextDecoder(\"utf-8\");\n\n// ===========================================================================\nexport class StatusAndHeaders {\n  statusline: string;\n  headers: Map<string, string> | Headers;\n\n  constructor({\n    statusline,\n    headers,\n  }: {\n    statusline: string;\n    headers: Map<string, string> | Headers;\n  }) {\n    this.statusline = statusline;\n    this.headers = headers;\n  }\n\n  toString() {\n    const buff = [this.statusline];\n\n    for (const [name, value] of this.headers) {\n      buff.push(`${name}: ${value}`);\n    }\n\n    return buff.join(\"\\r\\n\") + \"\\r\\n\";\n  }\n\n  async *iterSerialize(encoder: TextEncoder) {\n    yield encoder.encode(this.statusline);\n    yield CRLF;\n    for (const [name, value] of this.headers) {\n      yield encoder.encode(`${name}: ${value}\\r\\n`);\n    }\n  }\n\n  _protocol!: string;\n  _statusCode!: number | string;\n  _statusText!: string;\n\n  _parseResponseStatusLine() {\n    const parts = splitRemainder(this.statusline, \" \", 2);\n    this._protocol = parts[0] ?? \"\";\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- length checked\n    this._statusCode = parts.length > 1 ? Number(parts[1]) : \"\";\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- length checked\n    this._statusText = parts.length > 2 ? parts[2]! : \"\";\n  }\n\n  get statusCode() {\n    if (this._statusCode === undefined) {\n      this._parseResponseStatusLine();\n    }\n    return this._statusCode;\n  }\n\n  get protocol() {\n    if (this._protocol === undefined) {\n      this._parseResponseStatusLine();\n    }\n    return this._protocol;\n  }\n\n  get statusText() {\n    if (this._statusText === undefined) {\n      this._parseResponseStatusLine();\n    }\n    return this._statusText;\n  }\n\n  _method!: string;\n  _requestPath!: string;\n\n  _parseRequestStatusLine() {\n    const parts = this.statusline.split(\" \", 2);\n    this._method = parts[0] ?? \"\";\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- length checked\n    this._requestPath = parts.length > 1 ? parts[1]! : \"\";\n  }\n\n  get method() {\n    if (this._method === undefined) {\n      this._parseRequestStatusLine();\n    }\n    return this._method;\n  }\n\n  get requestPath() {\n    if (this._requestPath === undefined) {\n      this._parseRequestStatusLine();\n    }\n    return this._requestPath;\n  }\n}\n\n// ===========================================================================\nexport class StatusAndHeadersParser {\n  async parse(\n    reader: AsyncIterReader,\n    {\n      headersClass,\n      firstLine,\n    }: { firstLine?: string; headersClass: typeof Map | typeof Headers } = {\n      headersClass: Map,\n    }\n  ) {\n    const fullStatusLine = firstLine ? firstLine : await reader.readline();\n\n    if (!fullStatusLine) {\n      return null;\n    }\n\n    const statusline = fullStatusLine.trimEnd();\n\n    if (!statusline) {\n      return null;\n    }\n\n    const headers = new headersClass();\n\n    const headerBuff = await readToDoubleCRLF(reader);\n\n    let start = 0;\n    let nameEnd, valueStart, valueEnd;\n    let name = \"\";\n    let value;\n\n    while (start < headerBuff.length) {\n      valueEnd = headerBuff.indexOf(\"\\n\", start);\n\n      if (value && (headerBuff[start] === \" \" || headerBuff[start] === \"\\t\")) {\n        value += headerBuff\n          .slice(start, valueEnd < 0 ? undefined : valueEnd)\n          .trimEnd();\n      } else {\n        if (value) {\n          try {\n            headers.set(name, value);\n          } catch (e) {\n            // ignore\n          }\n          value = null;\n        }\n\n        nameEnd = headerBuff.indexOf(\":\", start);\n\n        valueStart = nameEnd < 0 ? start : nameEnd + 1;\n\n        if (nameEnd >= 0 && nameEnd < valueEnd) {\n          name = headerBuff.slice(start, nameEnd).trimStart();\n          value = headerBuff\n            .slice(valueStart, valueEnd < 0 ? undefined : valueEnd)\n            .trim();\n        } else {\n          value = null;\n        }\n      }\n\n      if (valueEnd < 0) {\n        break;\n      }\n\n      start = valueEnd + 1;\n    }\n\n    if (value) {\n      try {\n        headers.set(name, value);\n      } catch (e) {\n        // ignore\n      }\n    }\n\n    return new StatusAndHeaders({\n      statusline,\n      headers,\n    });\n  }\n}\n\n// ===========================================================================\nfunction splitRemainder(str: string, sep: string, limit: number) {\n  const parts = str.split(sep);\n  const newParts = parts.slice(0, limit);\n  const rest = parts.slice(limit);\n  if (rest.length > 0) {\n    newParts.push(parts.slice(limit).join(sep));\n  }\n  return newParts;\n}\n\n// ===========================================================================\nexport async function indexOfDoubleCRLF(\n  buffer: Uint8Array,\n  iter: AsyncIterator<Uint8Array, void, unknown>\n) {\n  let start = 0;\n\n  for (let i = 0; i < buffer.length - 4; i++) {\n    const inx = buffer.indexOf(13, start);\n    if (inx < 0) {\n      break;\n    }\n\n    if (inx + 3 >= buffer.length) {\n      const { value } = await iter.next();\n      if (!value) {\n        break;\n      }\n\n      const newBuff = new Uint8Array(value.length + buffer.length);\n      newBuff.set(buffer, 0);\n      newBuff.set(value, buffer.length);\n      buffer = newBuff;\n    }\n\n    if (\n      buffer[inx + 1] === 10 &&\n      buffer[inx + 2] === 13 &&\n      buffer[inx + 3] === 10\n    ) {\n      return [inx + 3, buffer] as const;\n    }\n\n    start = inx + 1;\n  }\n\n  return [-1, buffer] as const;\n}\n\n// ===========================================================================\nexport async function readToDoubleCRLF(reader: AsyncIterReader) {\n  const chunks = [];\n  let size = 0;\n\n  let inx = 0;\n\n  let lastChunk = null;\n\n  const iter = reader[Symbol.asyncIterator]();\n\n  for await (let chunk of iter) {\n    [inx, chunk] = await indexOfDoubleCRLF(chunk, iter);\n\n    if (inx >= 0) {\n      lastChunk = chunk;\n      break;\n    }\n\n    chunks.push(chunk);\n    size += chunk.byteLength;\n  }\n\n  if (lastChunk) {\n    const [first, remainder] = splitChunk(lastChunk, inx + 1);\n    chunks.push(first);\n    size += first.byteLength;\n\n    reader.unread(remainder);\n  } else if (!chunks.length) {\n    return \"\";\n  }\n\n  return decoder.decode(concatChunks(chunks, size));\n}\n\n// ===========================================================================\n","import uuid from \"uuid-random\";\nimport { BaseAsyncIterReader, AsyncIterReader, LimitReader } from \"./readers\";\nimport { StatusAndHeaders } from \"./statusandheaders\";\nimport { Source } from \"./types\";\n\nconst decoder = new TextDecoder(\"utf-8\");\nconst encoder = new TextEncoder();\n\nexport const WARC_1_1 = \"WARC/1.1\";\nexport const WARC_1_0 = \"WARC/1.0\";\n\nconst REVISIT_PROFILE_1_0 =\n  \"http://netpreserve.org/warc/1.0/revisit/identical-payload-digest\";\nconst REVISIT_PROFILE_1_1 =\n  \"http://netpreserve.org/warc/1.1/revisit/identical-payload-digest\";\n\nexport type WARCType =\n  | \"warcinfo\"\n  | \"response\"\n  | \"resource\"\n  | \"request\"\n  | \"metadata\"\n  | \"revisit\"\n  | \"conversion\"\n  | \"continuation\";\n\nconst defaultRecordCT: Partial<Record<WARCType, string>> = {\n  warcinfo: \"application/warc-fields\",\n  response: \"application/http; msgtype=response\",\n  revisit: \"application/http; msgtype=response\",\n  request: \"application/http; msgtype=request\",\n  metadata: \"application/warc-fields\",\n};\n\n// ===========================================================================\nexport type WARCRecordOpts = {\n  url?: string;\n  date?: string;\n  type?: WARCType;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  warcHeaders?: any;\n  filename?: string;\n  httpHeaders?: Record<string, string>;\n  statusline?: string;\n  warcVersion?: typeof WARC_1_0 | typeof WARC_1_1;\n  keepHeadersCase?: boolean;\n  refersToUrl?: string;\n  refersToDate?: string;\n};\n\n// ===========================================================================\nexport class WARCRecord extends BaseAsyncIterReader {\n  static create(\n    {\n      url,\n      date,\n      type,\n      warcHeaders = {},\n      filename = \"\",\n      httpHeaders = {},\n      statusline = \"HTTP/1.1 200 OK\",\n      warcVersion = WARC_1_0,\n      keepHeadersCase = true,\n      refersToUrl = undefined,\n      refersToDate = undefined,\n    }: WARCRecordOpts = {},\n    reader?: AsyncIterable<Uint8Array>\n  ) {\n    function checkDate(d: string) {\n      const date = d;\n      if (warcVersion === WARC_1_0) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- constant\n        d = d.split(\".\")[0]!;\n        if (d.charAt(date.length - 1) != \"Z\") {\n          d += \"Z\";\n        }\n      }\n      return d;\n    }\n\n    date = checkDate(date || new Date().toISOString());\n\n    warcHeaders = { ...warcHeaders };\n    if (type === \"warcinfo\") {\n      if (filename) {\n        warcHeaders[\"WARC-Filename\"] = filename;\n      }\n    } else {\n      warcHeaders[\"WARC-Target-URI\"] = url;\n    }\n\n    warcHeaders[\"WARC-Date\"] = date;\n    warcHeaders[\"WARC-Type\"] = type;\n\n    if (type === \"revisit\") {\n      warcHeaders[\"WARC-Profile\"] =\n        warcVersion === WARC_1_1 ? REVISIT_PROFILE_1_1 : REVISIT_PROFILE_1_0;\n      warcHeaders[\"WARC-Refers-To-Target-URI\"] = refersToUrl;\n      warcHeaders[\"WARC-Refers-To-Date\"] = checkDate(\n        refersToDate || new Date().toISOString()\n      );\n    }\n\n    warcHeaders = new StatusAndHeaders({\n      statusline: warcVersion,\n      headers: keepHeadersCase\n        ? new Map(Object.entries(warcHeaders))\n        : new Headers(warcHeaders),\n    });\n\n    if (!warcHeaders.headers.get(\"WARC-Record-ID\")) {\n      warcHeaders.headers.set(\"WARC-Record-ID\", `<urn:uuid:${uuid()}>`);\n    }\n\n    if (!warcHeaders.headers.get(\"Content-Type\")) {\n      warcHeaders.headers.set(\n        \"Content-Type\",\n        (type && defaultRecordCT[type]) || \"application/octet-stream\"\n      );\n    }\n\n    if (!reader) {\n      const emptyReader: () => AsyncGenerator<never, void, unknown> =\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\n        async function* () {};\n      reader = emptyReader();\n    }\n\n    const record = new WARCRecord({ warcHeaders, reader });\n    let headers: Map<string, string> | Headers | null = null;\n    let entries: [string, string][] = [];\n\n    switch (type) {\n      case \"response\":\n      case \"request\":\n      case \"revisit\":\n        entries = Object.entries(httpHeaders);\n        headers = keepHeadersCase ? new Map(entries) : new Headers(httpHeaders);\n\n        // for revisit records, if there are no http headers, don't add statusline\n        // for other request/response, add an empty statusline-only block\n        if (entries.length > 0 || type !== \"revisit\") {\n          record.httpHeaders = new StatusAndHeaders({ statusline, headers });\n        }\n        break;\n    }\n\n    return record;\n  }\n\n  static createWARCInfo(\n    opts: WARCRecordOpts = {},\n    info: Record<string, string>\n  ) {\n    async function* genInfo() {\n      for (const [name, value] of Object.entries(info)) {\n        yield encoder.encode(`${name}: ${value}\\r\\n`);\n      }\n    }\n\n    opts.type = \"warcinfo\";\n\n    return WARCRecord.create(opts, genInfo());\n  }\n\n  warcHeaders: StatusAndHeaders;\n  _reader: AsyncIterable<Uint8Array>;\n  _contentReader: BaseAsyncIterReader | null;\n  payload: Uint8Array | null;\n  httpHeaders: StatusAndHeaders | null;\n  consumed: \"content\" | \"raw\" | \"skipped\" | \"\";\n\n  _offset = 0;\n  _length = 0;\n\n  method = \"\";\n  requestBody = \"\";\n  _urlkey = \"\";\n\n  constructor({\n    warcHeaders,\n    reader,\n  }: {\n    warcHeaders: StatusAndHeaders;\n    reader: AsyncIterable<Uint8Array>;\n  }) {\n    super();\n\n    this.warcHeaders = warcHeaders;\n\n    this._reader = reader;\n    this._contentReader = null;\n\n    this.payload = null;\n    this.httpHeaders = null;\n\n    this.consumed = \"\";\n\n    this.fixUp();\n  }\n\n  getResponseInfo() {\n    const httpHeaders = this.httpHeaders;\n\n    if (!httpHeaders) {\n      return null;\n    }\n\n    // match parameters for Response(..., initOpts);\n    return {\n      headers: httpHeaders.headers,\n      status: httpHeaders.statusCode,\n      statusText: httpHeaders.statusText,\n    };\n  }\n\n  fixUp() {\n    // Fix wget-style error where WARC-Target-URI is wrapped in <>\n    const uri = this.warcHeaders.headers.get(\"WARC-Target-URI\");\n    if (uri && uri.startsWith(\"<\") && uri.endsWith(\">\")) {\n      this.warcHeaders.headers.set(\"WARC-Target-URI\", uri.slice(1, -1));\n    }\n  }\n\n  override async readFully(isContent = false) {\n    // if have httpHeaders, need to consider transfer and content decoding is decoding content vs raw data\n    if (this.httpHeaders) {\n      // if payload is empty, just return\n      if (this.payload && !this.payload.length) {\n        return this.payload;\n      }\n\n      // otherwise, can't serialize payload as raw if already started reading\n      if (this._contentReader && !isContent) {\n        throw new TypeError(\n          \"WARC Record decoding already started, but requesting raw payload\"\n        );\n      }\n\n      // reading content, but already consumed raw data, convert\n      if (isContent && this.consumed === \"raw\" && this.payload) {\n        return await this._createDecodingReader([this.payload]).readFully();\n      }\n    }\n\n    if (this.payload) {\n      return this.payload;\n    }\n\n    if (isContent) {\n      this.payload = await super.readFully();\n      this.consumed = \"content\";\n    } else {\n      this.payload = await WARCRecord.readFully(this._reader);\n      this.consumed = \"raw\";\n    }\n\n    return this.payload;\n  }\n\n  get reader() {\n    if (this._contentReader) {\n      throw new TypeError(\n        \"WARC Record decoding already started, but requesting raw payload\"\n      );\n    }\n\n    return this._reader;\n  }\n\n  get contentReader() {\n    if (!this.httpHeaders) {\n      return this._reader;\n    }\n\n    if (!this._contentReader) {\n      this._contentReader = this._createDecodingReader(this._reader);\n    }\n\n    return this._contentReader;\n  }\n\n  _createDecodingReader(source: Source) {\n    // only called if this.httpHeaders !== null\n    if (!this.httpHeaders) {\n      throw new Error(\n        \"WARCRecord cannot call _createDecodingReader when this.httpHeaders === null\"\n      );\n    }\n\n    let contentEnc = this.httpHeaders.headers.get(\"Content-Encoding\") as string;\n    const transferEnc = this.httpHeaders.headers.get(\n      \"Transfer-Encoding\"\n    ) as string;\n\n    const chunked = transferEnc === \"chunked\";\n\n    // Transfer-Encoding is not chunked and no Content-Encoding\n    // try Transfer-Encoding as Content-Encoding\n    if (!contentEnc && !chunked) {\n      contentEnc = transferEnc;\n    }\n\n    return new AsyncIterReader(source, contentEnc, chunked);\n  }\n\n  async readlineRaw(maxLength?: number) {\n    if (this.consumed) {\n      throw new Error(\n        \"Record already consumed.. Perhaps a promise was not awaited?\"\n      );\n    }\n    if (this.contentReader instanceof BaseAsyncIterReader) {\n      return this.contentReader.readlineRaw(maxLength);\n    }\n    throw new Error(\n      \"WARCRecord cannot call readlineRaw on this.contentReader if it does not extend BaseAsyncIterReader\"\n    );\n  }\n\n  async contentText() {\n    const payload = await this.readFully(true);\n    return decoder.decode(payload);\n  }\n\n  async *[Symbol.asyncIterator]() {\n    for await (const chunk of this.contentReader) {\n      yield chunk;\n      if (this.consumed) {\n        throw new Error(\n          \"Record already consumed.. Perhaps a promise was not awaited?\"\n        );\n      }\n    }\n\n    this.consumed = \"content\";\n  }\n\n  async skipFully() {\n    if (this.consumed) {\n      return;\n    }\n    if (this._reader instanceof LimitReader) {\n      const res = await this._reader.skipFully();\n      this.consumed = \"skipped\";\n      return res;\n    }\n    throw new Error(\n      \"WARCRecord cannot call skipFully on this._reader if it is not a LimitReader\"\n    );\n  }\n\n  warcHeader(name: string) {\n    return this.warcHeaders.headers.get(name);\n  }\n\n  get warcType() {\n    return this.warcHeaders.headers.get(\"WARC-Type\");\n  }\n\n  get warcTargetURI() {\n    return this.warcHeaders.headers.get(\"WARC-Target-URI\");\n  }\n\n  get warcDate() {\n    return this.warcHeaders.headers.get(\"WARC-Date\");\n  }\n\n  get warcRefersToTargetURI() {\n    return this.warcHeaders.headers.get(\"WARC-Refers-To-Target-URI\");\n  }\n\n  get warcRefersToDate() {\n    return this.warcHeaders.headers.get(\"WARC-Refers-To-Date\");\n  }\n\n  get warcPayloadDigest() {\n    return this.warcHeaders.headers.get(\"WARC-Payload-Digest\");\n  }\n\n  get warcBlockDigest() {\n    return this.warcHeaders.headers.get(\"WARC-Block-Digest\");\n  }\n\n  get warcContentType() {\n    return this.warcHeaders.headers.get(\"Content-Type\");\n  }\n\n  get warcContentLength() {\n    return Number(this.warcHeaders.headers.get(\"Content-Length\"));\n  }\n}\n\n// ===========================================================================\n","import { StatusAndHeadersParser, StatusAndHeaders } from \"./statusandheaders\";\nimport { WARCRecord } from \"./warcrecord\";\nimport { AsyncIterReader, LimitReader } from \"./readers\";\nimport { Source } from \"./types\";\n\nconst decoder = new TextDecoder();\nconst EMPTY = new Uint8Array([]);\n\nexport type WARCParserOpts = {\n  keepHeadersCase?: boolean;\n  parseHttp?: boolean;\n};\n\n// ===========================================================================\nexport class WARCParser {\n  static parse(source: Source, options?: WARCParserOpts) {\n    return new WARCParser(source, options).parse();\n  }\n\n  static iterRecords(source: Source, options?: WARCParserOpts) {\n    return new WARCParser(source, options)[Symbol.asyncIterator]();\n  }\n\n  _offset: number;\n  _warcHeadersLength: number;\n\n  _headersClass: typeof Map | typeof Headers;\n  _parseHttp: boolean;\n\n  _atRecordBoundary: boolean;\n\n  _reader: AsyncIterReader;\n\n  _record: WARCRecord | null;\n\n  constructor(\n    source: Source,\n    { keepHeadersCase = false, parseHttp = true }: WARCParserOpts = {}\n  ) {\n    this._offset = 0;\n    this._warcHeadersLength = 0;\n\n    this._headersClass = keepHeadersCase ? Map : Headers;\n    this._parseHttp = parseHttp;\n\n    this._atRecordBoundary = true;\n\n    if (!(source instanceof AsyncIterReader)) {\n      this._reader = new AsyncIterReader(source);\n    } else {\n      this._reader = source;\n    }\n\n    this._record = null;\n  }\n\n  async readToNextRecord() {\n    let nextline;\n\n    if (!this._atRecordBoundary && this._reader && this._record) {\n      await this._record.skipFully();\n\n      let lineLen = 0;\n\n      nextline = await this._reader.readlineRaw();\n      if (!nextline) {\n        nextline = EMPTY;\n      } else {\n        lineLen = nextline.byteLength - 1;\n\n        while (lineLen >= 0) {\n          const value = nextline[lineLen - 1];\n          if (value !== 10 && value !== 13) {\n            break;\n          }\n          lineLen--;\n        }\n      }\n\n      if (lineLen) {\n        console.warn(`Content-Length Too Small: Record not followed by newline, \\\nRemainder Length: ${lineLen}, \\\nOffset: ${this._reader.getRawOffset() - nextline.byteLength}`);\n      }\n\n      if (this._reader.compressed) {\n        await this._reader.skipSize(2);\n        nextline = EMPTY;\n      } else {\n        nextline = await this._reader.readlineRaw();\n\n        // consume remaining new lines\n        while (nextline && nextline.byteLength === 2) {\n          nextline = await this._reader.readlineRaw();\n        }\n      }\n    }\n\n    this._atRecordBoundary = true;\n    return nextline ? decoder.decode(nextline) : \"\";\n  }\n\n  _initRecordReader(warcHeaders: StatusAndHeaders) {\n    return new LimitReader(\n      this._reader,\n      Number(warcHeaders.headers.get(\"Content-Length\") || 0)\n    );\n  }\n\n  async parse() {\n    const firstLine = await this.readToNextRecord();\n\n    this._offset = this._reader.getRawOffset() - firstLine.length;\n\n    const headersParser = new StatusAndHeadersParser();\n    const warcHeaders = await headersParser.parse(this._reader, {\n      firstLine,\n      headersClass: this._headersClass,\n    });\n\n    if (!warcHeaders) {\n      return null;\n    }\n\n    this._warcHeadersLength = this._reader.getReadOffset();\n\n    const record = new WARCRecord({\n      warcHeaders,\n      reader: this._initRecordReader(warcHeaders),\n    });\n\n    this._atRecordBoundary = false;\n    this._record = record;\n\n    if (this._parseHttp) {\n      switch (record.warcType) {\n        case \"response\":\n        case \"request\":\n          await this._addHttpHeaders(record, headersParser);\n          break;\n\n        case \"revisit\":\n          if (record.warcContentLength > 0) {\n            await this._addHttpHeaders(record, headersParser);\n          }\n          break;\n      }\n    }\n\n    return record;\n  }\n\n  get offset() {\n    return this._offset;\n  }\n\n  get recordLength() {\n    return this._reader.getRawLength(this._offset);\n  }\n\n  async *[Symbol.asyncIterator]() {\n    let record = null;\n\n    while ((record = await this.parse()) !== null) {\n      yield record;\n    }\n\n    this._record = null;\n  }\n\n  async _addHttpHeaders(\n    record: WARCRecord,\n    headersParser: StatusAndHeadersParser\n  ) {\n    const httpHeaders = await headersParser.parse(this._reader, {\n      headersClass: this._headersClass,\n    });\n    record.httpHeaders = httpHeaders;\n\n    const headersLen = this._reader.getReadOffset() - this._warcHeadersLength;\n    if (record.reader instanceof LimitReader) {\n      record.reader.setLimitSkip(record.warcContentLength - headersLen);\n    }\n  }\n}\n\n// ===========================================================================\n","//import base32 from \"hi-base32\";\nimport base32Encode from \"base32-encode\";\nimport pako from \"pako\";\n\nimport { WARCRecord } from \"./warcrecord\";\nimport { BaseAsyncIterReader } from \"./readers\";\nimport { CRLF, CRLFCRLF } from \"./statusandheaders\";\nimport { concatChunks } from \"./utils\";\n\nconst encoder = new TextEncoder();\n\n// ===========================================================================\nexport type WARCSerializerOpts = {\n  gzip?: boolean;\n  digest?: {\n    algo?: AlgorithmIdentifier;\n    prefix?: string;\n    base32?: boolean;\n  };\n};\nexport class WARCSerializer extends BaseAsyncIterReader {\n  static async serialize(record: WARCRecord, opts?: WARCSerializerOpts) {\n    const s = new WARCSerializer(record, opts);\n    return await s.readFully();\n  }\n\n  static base16(hashBuffer: ArrayBuffer) {\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n    return hashArray.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n  }\n\n  record: WARCRecord;\n  gzip = false;\n  digestAlgo: AlgorithmIdentifier = \"\";\n  digestAlgoPrefix = \"\";\n  digestBase32 = false;\n\n  constructor(record: WARCRecord, opts: WARCSerializerOpts = {}) {\n    super();\n    this.record = record;\n    this.gzip = Boolean(opts.gzip);\n\n    const digestOpts = (opts && opts.digest) || {};\n\n    if (\n      record.warcType !== \"revisit\" &&\n      record.warcType !== \"warcinfo\" &&\n      (!record.warcPayloadDigest || !record.warcBlockDigest)\n    ) {\n      this.digestAlgo = digestOpts?.algo || \"sha-256\";\n      this.digestAlgoPrefix = digestOpts?.prefix || \"sha256:\";\n      this.digestBase32 = Boolean(digestOpts?.base32);\n    } else {\n      this.digestAlgo = \"\";\n    }\n  }\n\n  async *[Symbol.asyncIterator]() {\n    if (!this.gzip) {\n      yield* this.generateRecord();\n      return;\n    }\n\n    let cs = null;\n\n    if (\"CompressionStream\" in globalThis) {\n      cs = new globalThis.CompressionStream(\"gzip\");\n      yield* this.streamCompress(cs);\n    } else {\n      yield* this.pakoCompress();\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  override async readlineRaw(maxLength?: number): Promise<Uint8Array | null> {\n    return null;\n  }\n\n  async *pakoCompress() {\n    const deflater = new pako.Deflate({ gzip: true });\n\n    let lastChunk: Uint8Array | null = null;\n\n    for await (const chunk of this.generateRecord()) {\n      if (lastChunk && lastChunk.length > 0) {\n        deflater.push(lastChunk);\n      }\n      lastChunk = chunk;\n\n      // @ts-expect-error Deflate has property chunks in implementation\n      while (deflater.chunks.length) {\n        // @ts-expect-error Deflate has property chunks in implementation\n        yield deflater.chunks.shift();\n      }\n    }\n\n    if (lastChunk) {\n      deflater.push(lastChunk, true);\n    }\n    yield deflater.result;\n  }\n\n  async *streamCompress(cs: CompressionStream) {\n    const recordIter = this.generateRecord();\n\n    const source = new ReadableStream({\n      async pull(controller) {\n        const res = await recordIter.next();\n        if (!res.done) {\n          controller.enqueue(res.value);\n        } else {\n          controller.close();\n        }\n      },\n    });\n\n    source.pipeThrough(cs);\n\n    let res = null;\n\n    const reader = cs.readable.getReader();\n\n    while ((res = await reader.read()) && !res.done) {\n      yield res.value;\n    }\n  }\n\n  async digestMessage(chunk: BufferSource) {\n    const hashBuffer = await crypto.subtle.digest(this.digestAlgo, chunk);\n    return (\n      this.digestAlgoPrefix +\n      (this.digestBase32\n        ? base32Encode(hashBuffer, \"RFC4648\")\n        : WARCSerializer.base16(hashBuffer))\n    );\n  }\n\n  async *generateRecord() {\n    let size = 0;\n\n    let httpHeadersBuff: Uint8Array | null = null;\n\n    if (this.record.httpHeaders) {\n      httpHeadersBuff = encoder.encode(\n        this.record.httpHeaders.toString() + \"\\r\\n\"\n      );\n      size += httpHeadersBuff.length;\n    }\n\n    const payload = await this.record.readFully();\n    size += payload.length;\n\n    // if digestAlgo is set, compute digests, otherwise only content-length\n    if (this.digestAlgo) {\n      const payloadDigest = await this.digestMessage(payload);\n      /* eslint-disable indent -- offsetTernaryExpressions is broken */\n      const blockDigest = httpHeadersBuff\n        ? await this.digestMessage(\n            concatChunks([httpHeadersBuff, payload], size)\n          )\n        : payloadDigest;\n      /* eslint-enable indent */\n\n      this.record.warcHeaders.headers.set(\"WARC-Payload-Digest\", payloadDigest);\n      this.record.warcHeaders.headers.set(\"WARC-Block-Digest\", blockDigest);\n    }\n\n    this.record.warcHeaders.headers.set(\"Content-Length\", size.toString());\n\n    const warcHeadersBuff = encoder.encode(this.record.warcHeaders.toString());\n\n    yield warcHeadersBuff;\n    yield CRLF;\n\n    if (httpHeadersBuff) {\n      yield httpHeadersBuff;\n    }\n\n    yield payload;\n\n    yield CRLFCRLF;\n  }\n}\n","import { WritableStreamBuffer } from \"stream-buffers\";\n\nimport { WARCParser } from \"./warcparser\";\nimport { WARCRecord } from \"./warcrecord\";\nimport { postToGetUrl, getSurt } from \"./utils\";\nimport { IndexCommandArgs, CdxIndexCommandArgs } from \"../commands\";\nimport { StreamResults, Request } from \"./types\";\n\nconst DEFAULT_FIELDS = [\"offset\", \"warc-type\", \"warc-target-uri\"];\n// ===========================================================================\nabstract class BaseIndexer {\n  opts: Partial<IndexCommandArgs>;\n  out: WritableStreamBuffer | NodeJS.WriteStream;\n  fields: string[];\n  parseHttp: boolean;\n\n  constructor(\n    out: WritableStreamBuffer | NodeJS.WriteStream,\n    opts: Partial<IndexCommandArgs> = {},\n  ) {\n    this.opts = opts;\n    this.out = out;\n    this.fields = opts && opts.fields ? opts.fields.split(\",\") : DEFAULT_FIELDS;\n    this.parseHttp = false;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  serialize(result: Record<string, any>) {\n    return JSON.stringify(result) + \"\\n\";\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  write(result: Record<string, any>) {\n    // @ts-expect-error incompatible function signatures are actually the same\n    this.out.write(this.serialize(result));\n  }\n\n  async run(files: StreamResults) {\n    for await (const result of this.iterIndex(files)) {\n      this.write(result);\n    }\n  }\n\n  async *iterIndex(files: StreamResults) {\n    const params = { strictHeaders: true, parseHttp: this.parseHttp };\n\n    for (const { filename, reader } of files) {\n      const parser = new WARCParser(reader, params);\n\n      yield* this.iterRecords(parser, filename);\n    }\n  }\n\n  async *iterRecords(parser: WARCParser, filename: string) {\n    for await (const record of parser) {\n      await record.skipFully();\n      const result = this.indexRecord(record, parser, filename);\n      if (result) {\n        yield result;\n      }\n    }\n  }\n\n  filterRecord?(record: WARCRecord): boolean;\n\n  indexRecord(\n    record: WARCRecord,\n    parser: WARCParser,\n    filename: string\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Record<string, any> | null {\n    if (this.filterRecord && !this.filterRecord(record)) {\n      return null;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const result: Record<string, any> = {};\n\n    const offset = parser.offset;\n    const length = parser.recordLength;\n\n    const special = { offset, length, filename };\n\n    for (const field of this.fields) {\n      if (field in special) {\n        result[field] = special[field as keyof typeof special];\n      } else {\n        this.setField(field, record, result);\n      }\n    }\n\n    return result;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  setField(field: string, record: WARCRecord, result: Record<string, any>) {\n    const value = this.getField(field, record);\n    if (value !== null) {\n      result[field] = value;\n    }\n  }\n\n  getField(field: string, record: WARCRecord) {\n    if (field === \"http:status\") {\n      if (\n        record.httpHeaders &&\n        (record.warcType === \"response\" || record.warcType === \"revisit\")\n      ) {\n        return record.httpHeaders.statusCode;\n      }\n      return null;\n    }\n\n    if (field.startsWith(\"http:\")) {\n      if (record.httpHeaders) {\n        return record.httpHeaders.headers.get(field.slice(5));\n      }\n      return null;\n    }\n\n    return record.warcHeaders.headers.get(field) || null;\n  }\n}\n\n// ===========================================================================\nexport class Indexer extends BaseIndexer {\n  constructor(\n    out: WritableStreamBuffer | NodeJS.WriteStream,\n    opts?: Partial<IndexCommandArgs>,\n  ) {\n    super(out, opts);\n\n    for (const field of this.fields) {\n      if (field.startsWith(\"http:\")) {\n        this.parseHttp = true;\n        break;\n      }\n    }\n  }\n}\n\n// ===========================================================================\nconst DEFAULT_CDX_FIELDS =\n  \"urlkey,timestamp,url,mime,status,digest,length,offset,filename\".split(\",\");\nconst DEFAULT_LEGACY_CDX_FIELDS =\n  \"urlkey,timestamp,url,mime,status,digest,redirect,meta,length,offset,filename\".split(\n    \",\"\n  );\n\n// ===========================================================================\nexport class CDXIndexer extends Indexer {\n  includeAll: boolean;\n  noSurt: boolean;\n  _lastRecord: WARCRecord | null;\n\n  constructor(\n    out: WritableStreamBuffer | NodeJS.WriteStream,\n    opts?: Partial<CdxIndexCommandArgs>,\n  ) {\n    super(out, opts);\n    this.includeAll = Boolean(opts?.all);\n    this.fields = DEFAULT_CDX_FIELDS;\n    this.parseHttp = true;\n    this.noSurt = Boolean(opts?.noSurt);\n    this._lastRecord = null;\n\n    switch (opts?.format) {\n      case \"cdxj\":\n        this.serialize = this.serializeCDXJ;\n        break;\n\n      case \"cdx\":\n        this.serialize = this.serializeCDX11;\n        break;\n\n      case \"json\":\n      default:\n        // default write\n        break;\n    }\n  }\n\n  override async *iterRecords(parser: WARCParser, filename: string) {\n    this._lastRecord = null;\n\n    for await (const record of parser) {\n      await record.readFully();\n      const result = this.indexRecord(record, parser, filename);\n      if (result) {\n        yield result;\n      }\n    }\n\n    const result = this.indexRecord(null, parser, filename);\n    if (result) {\n      yield result;\n    }\n  }\n\n  override filterRecord(record: WARCRecord) {\n    if (this.includeAll) {\n      return true;\n    }\n\n    const type = record.warcType;\n    if (type === \"request\" || type === \"warcinfo\") {\n      return false;\n    }\n\n    return true;\n  }\n\n  override indexRecord(\n    record: WARCRecord | null,\n    parser: WARCParser,\n    filename: string\n  ) {\n    if (this.includeAll) {\n      if (!record) {\n        return null;\n      }\n      return super.indexRecord(record, parser, filename);\n    }\n\n    const lastRecord = this._lastRecord;\n\n    if (record) {\n      record._offset = parser.offset;\n      record._length = parser.recordLength;\n    }\n\n    if (!lastRecord) {\n      this._lastRecord = record;\n      return null;\n    }\n\n    if (!record || lastRecord.warcTargetURI != record.warcTargetURI) {\n      this._lastRecord = record;\n      return this.indexRecordPair(lastRecord, null, parser, filename);\n    }\n\n    if (record.warcType === \"request\" && lastRecord.warcType === \"response\") {\n      this._lastRecord = null;\n      return this.indexRecordPair(lastRecord, record, parser, filename);\n    } else if (\n      record.warcType === \"response\" &&\n      lastRecord.warcType === \"request\"\n    ) {\n      this._lastRecord = null;\n      return this.indexRecordPair(record, lastRecord, parser, filename);\n    } else {\n      this._lastRecord = record;\n      return this.indexRecordPair(lastRecord, null, parser, filename);\n    }\n  }\n\n  indexRecordPair(\n    record: WARCRecord,\n    reqRecord: WARCRecord | null,\n    parser: WARCParser,\n    filename: string\n  ) {\n    let method;\n    let requestBody;\n    let url = record.warcTargetURI || \"\";\n\n    if (\n      reqRecord &&\n      reqRecord.httpHeaders &&\n      reqRecord.httpHeaders.method !== \"GET\"\n    ) {\n      const request: Request = {\n        url,\n        method: reqRecord.httpHeaders.method,\n        headers: reqRecord.httpHeaders.headers,\n        postData: reqRecord.payload,\n      };\n\n      method = request.method;\n\n      if (postToGetUrl(request)) {\n        requestBody = request.requestBody;\n        record.method = method;\n        record.requestBody = requestBody;\n        url = request.url;\n      }\n    }\n\n    record._urlkey = url;\n\n    const res = super.indexRecord(record, parser, filename);\n    if (res) {\n      if (record && record._offset !== undefined) {\n        res[\"offset\"] = record._offset;\n        res[\"length\"] = record._length;\n      }\n      if (method) {\n        res[\"method\"] = method;\n      }\n      if (requestBody) {\n        res[\"requestBody\"] = requestBody;\n      }\n    }\n\n    return res;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  serializeCDXJ(result: Record<string, any>) {\n    const { urlkey, timestamp } = result;\n    delete result[\"urlkey\"];\n    delete result[\"timestamp\"];\n\n    return `${urlkey} ${timestamp} ${JSON.stringify(result)}\\n`;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  serializeCDX11(result: Record<string, any>) {\n    const value = [];\n\n    for (const field of DEFAULT_LEGACY_CDX_FIELDS) {\n      value.push(result[field] != undefined ? result[field] : \"-\");\n    }\n\n    return value.join(\" \") + \"\\n\";\n  }\n\n  override getField(field: string, record: WARCRecord) {\n    let value = null;\n\n    switch (field) {\n      case \"urlkey\":\n        value = record._urlkey || record.warcTargetURI || null;\n        return this.noSurt || value === null ? value : getSurt(value);\n\n      case \"timestamp\":\n        value = record.warcDate ?? \"\";\n        return value.replace(/[-:T]/g, \"\").slice(0, 14);\n\n      case \"url\":\n        return record.warcTargetURI;\n\n      case \"mime\":\n        switch (record.warcType) {\n          case \"revisit\":\n            return \"warc/revisit\";\n\n          case \"response\":\n          case \"request\":\n            field = \"http:content-type\";\n            break;\n\n          default:\n            field = \"content-type\";\n        }\n        value = super.getField(field, record);\n        return value ? value.toString().split(\";\", 1)[0]?.trim() : null;\n\n      case \"status\":\n        return super.getField(\"http:status\", record);\n\n      case \"digest\":\n        value = record.warcPayloadDigest;\n        return value ? value.split(\":\", 2)[1] : null;\n\n      default:\n        return null;\n    }\n  }\n}\n"],"mappings":"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","names":["src_exports","__export","AsyncIterReader","BaseAsyncIterReader","CDXIndexer","Indexer","LimitReader","NoConcatInflator","StatusAndHeaders","StatusAndHeadersParser","WARCParser","WARCRecord","WARCSerializer","WARC_1_0","WARC_1_1","appendRequestQuery","concatChunks","getSurt","jsonToQueryParams","jsonToQueryString","mfdToQueryParams","mfdToQueryString","postToGetUrl","splitChunk","__toCommonJS","import_pako","binaryToString","data","string","accumulator","value","rxEscape","getSurt","url","urlLower","urlObj","surt","key","rx","postToGetUrl","request","method","headers","postData","requestMime","decodeIfNeeded","query","jsonToQueryString","content_type","mfdToQueryString","appendRequestQuery","start","jsonToQueryParams","json","ignoreInvalid","q","dupes","getKey","k","v","e","mfdToQueryParams","mfd","contentType","params","boundary","parts","part","m","concatChunks","chunks","size","buffer","offset","chunk","splitChunk","inx","decoder","NoConcatInflator","pako","options","reader","status","BaseAsyncIterReader","iter","chunks","size","chunk","concatChunks","streamIter","controller","result","maxLength","lineBuff","line","isIterable","input","isAsyncIterable","AsyncIterReader","streamOrIter","compressed","dechunk","source","res","first","sep","newValue","value","original","avail_in","inx","lastChunk","lineInx","remainder","splitChunk","sizeLimit","skip","prevOffset","LimitReader","limit","origLimit","CRLF","CRLFCRLF","decoder","StatusAndHeaders","statusline","headers","buff","name","value","encoder","parts","splitRemainder","StatusAndHeadersParser","reader","headersClass","firstLine","fullStatusLine","headerBuff","readToDoubleCRLF","start","nameEnd","valueStart","valueEnd","str","sep","limit","newParts","indexOfDoubleCRLF","buffer","iter","i","inx","newBuff","chunks","size","lastChunk","chunk","first","remainder","splitChunk","concatChunks","import_uuid_random","decoder","encoder","WARC_1_1","WARC_1_0","REVISIT_PROFILE_1_0","REVISIT_PROFILE_1_1","defaultRecordCT","WARCRecord","BaseAsyncIterReader","warcHeaders","reader","url","date","type","filename","httpHeaders","statusline","warcVersion","keepHeadersCase","refersToUrl","refersToDate","checkDate","d","StatusAndHeaders","uuid","record","headers","entries","opts","info","genInfo","name","value","uri","isContent","source","contentEnc","transferEnc","chunked","AsyncIterReader","maxLength","payload","chunk","LimitReader","res","decoder","EMPTY","WARCParser","source","options","keepHeadersCase","parseHttp","AsyncIterReader","nextline","lineLen","value","warcHeaders","LimitReader","firstLine","headersParser","StatusAndHeadersParser","record","WARCRecord","httpHeaders","headersLen","import_base32_encode","import_pako","encoder","WARCSerializer","BaseAsyncIterReader","record","opts","digestOpts","hashBuffer","b","cs","maxLength","deflater","pako","lastChunk","chunk","recordIter","controller","res","reader","base32Encode","size","httpHeadersBuff","payload","payloadDigest","blockDigest","concatChunks","CRLF","CRLFCRLF","DEFAULT_FIELDS","BaseIndexer","out","opts","result","files","params","filename","reader","parser","WARCParser","record","offset","length","special","field","value","Indexer","DEFAULT_CDX_FIELDS","DEFAULT_LEGACY_CDX_FIELDS","CDXIndexer","type","lastRecord","reqRecord","method","requestBody","url","request","postToGetUrl","res","urlkey","timestamp","getSurt"]}